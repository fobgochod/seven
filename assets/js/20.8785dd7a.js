(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{566:function(v,_,e){"use strict";e.r(_);var l=e(12),t=Object(l.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"多线程与高并发（进程内高并发）"}},[v._v("多线程与高并发（进程内高并发）")]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("总览")]),v._v(" "),e("ol",[e("li",[v._v("单机高并发应该掌握的线程基础：线程状态，异常与锁等 "),e("a",{attrs:{href:"https://ke.qq.com/webcourse/index.html#cid=398381&term_id=100475149&taid=3385529446306861&type=1024&vid=5285890793201449862",target:"_blank",rel:"noopener noreferrer"}},[v._v("视频41"),e("OutboundLink")],1)]),v._v(" "),e("li",[v._v("解析自旋锁CAS操作与volatile "),e("a",{attrs:{href:"https://ke.qq.com/webcourse/index.html#cid=398381&term_id=100475149&taid=3826180205974573&type=1024&vid=5285890793489922415",target:"_blank",rel:"noopener noreferrer"}},[v._v("视频46"),e("OutboundLink")],1)]),v._v(" "),e("li",[v._v("JUC包下AtomicXXX类与新的同步机制：Latch Semaphore等 "),e("a",{attrs:{href:"https://ke.qq.com/webcourse/index.html#cid=398381&term_id=100475149&taid=3852263542363181&type=1024&vid=5285890793810836226",target:"_blank",rel:"noopener noreferrer"}},[v._v("视频52"),e("OutboundLink")],1)]),v._v(" "),e("li",[v._v("LockSupport，高频面试题，AQS源码，以及源码阅读方法论 "),e("a",{attrs:{href:"https://ke.qq.com/webcourse/index.html#cid=398381&term_id=100475149&taid=3385576690947117&type=1024&vid=5285890794254224450",target:"_blank",rel:"noopener noreferrer"}},[v._v("视频58"),e("OutboundLink")],1)]),v._v(" "),e("li",[v._v("强软弱虚四种引用以及ThreadLocal的原理与源码 "),e("a",{attrs:{href:"https://ke.qq.com/webcourse/index.html#cid=398381&term_id=100475149&taid=3385593870816301&type=1024&vid=5285890794418013695",target:"_blank",rel:"noopener noreferrer"}},[v._v("视频62"),e("OutboundLink")],1)]),v._v(" "),e("li",[v._v("线程池可用的各种高并发容器详解：CopyOnWriteList，BlockingQueue等 "),e("a",{attrs:{href:"#"}},[v._v("视频64")])]),v._v(" "),e("li",[v._v("详解线程池：自定义线程池，JDK自带线程池，ForkJoin，源码解析等(一） "),e("a",{attrs:{href:"#"}},[v._v("视频69")])]),v._v(" "),e("li",[v._v("详解线程池：自定义线程池，JDK自带线程池，ForkJoin，源码解析等(二） "),e("a",{attrs:{href:"#"}},[v._v("视频74")])]),v._v(" "),e("li",[v._v("单机压测工具JMH，单机最快MQ - Disruptor原理解析 "),e("a",{attrs:{href:"#"}},[v._v("视频76")])])])]),v._v(" "),e("p",{staticClass:"tip"},[v._v("进度")]),v._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#单机高并发应该掌握的线程基础：线程状态，异常与锁等"}},[v._v("单机高并发应该掌握的线程基础：线程状态，异常与锁等")])]),e("li",[e("a",{attrs:{href:"#解析自旋锁cas操作与volatile"}},[v._v("解析自旋锁CAS操作与volatile")])]),e("li",[e("a",{attrs:{href:"#juc包下atomicxxx类与新的同步机制：latch-semaphore等"}},[v._v("JUC包下AtomicXXX类与新的同步机制：Latch Semaphore等")])]),e("li",[e("a",{attrs:{href:"#locksupport，高频面试题，aqs源码，以及源码阅读方法论"}},[v._v("LockSupport，高频面试题，AQS源码，以及源码阅读方法论")])]),e("li",[e("a",{attrs:{href:"#强软弱虚四种引用以及threadlocal的原理与源码"}},[v._v("强软弱虚四种引用以及ThreadLocal的原理与源码")])])])]),e("p"),v._v(" "),e("h2",{attrs:{id:"单机高并发应该掌握的线程基础：线程状态，异常与锁等"}},[v._v("单机高并发应该掌握的线程基础：线程状态，异常与锁等")]),v._v(" "),e("ul",[e("li",[v._v("线程的概念、启动方式、常用方法")]),v._v(" "),e("li",[v._v("synchronized(Object)\n"),e("ul",[e("li",[v._v("不能用String常量、Integer、Long")]),v._v(" "),e("li",[v._v("object")])])]),v._v(" "),e("li",[v._v("线程同步")]),v._v(" "),e("li",[v._v("synchronized\n"),e("ul",[e("li",[v._v("锁的是对象不是代码")]),v._v(" "),e("li",[v._v("this *.class")]),v._v(" "),e("li",[v._v("锁的方法 非锁定方法 可以同时执行")]),v._v(" "),e("li",[v._v("锁升级\n"),e("ul",[e("li",[v._v("无锁 偏向锁 自旋锁 重量级锁")]),v._v(" "),e("li",[v._v("执行时间短（加锁代码），线程数少，用自旋")]),v._v(" "),e("li",[v._v("执行时间长，线程数多，用系统锁")])])])])])]),v._v(" "),e("h2",{attrs:{id:"解析自旋锁cas操作与volatile"}},[v._v("解析自旋锁CAS操作与volatile")]),v._v(" "),e("ul",[e("li",[v._v("volatile\n"),e("ul",[e("li",[v._v("保证线程可见性\n"),e("ul",[e("li",[v._v("MESI")]),v._v(" "),e("li",[v._v("缓存一致性协议")])])]),v._v(" "),e("li",[v._v("禁止指令重排\n"),e("ul",[e("li",[v._v("DCL 单例")]),v._v(" "),e("li",[v._v("Double Check Lock")]),v._v(" "),e("li",[v._v("loadfence原语指令")]),v._v(" "),e("li",[v._v("storefence原语指令")])])])])])]),v._v(" "),e("p",[v._v("class A {\nprivate a = 1;\n}")]),v._v(" "),e("p",[v._v("A obj = new A();")]),v._v(" "),e("ul",[e("li",[v._v("申请内存，对象内部默认值 此时a=0")]),v._v(" "),e("li",[v._v("对象初始化，调用对象初始化方法 此时a=1")]),v._v(" "),e("li",[v._v("对象赋值 将内存指向obj")])]),v._v(" "),e("p",[v._v("第二三步可能发生指令重排")]),v._v(" "),e("p",[v._v("CAS(无锁优化 自旋 乐观锁)")]),v._v(" "),e("ul",[e("li",[v._v("Compare And Set/Swap")]),v._v(" "),e("li",[v._v("cas(V, Expected, NewValue)")]),v._v(" "),e("li",[v._v("if V == E\nV = New\notherwise try again or fail")]),v._v(" "),e("li",[v._v("CPU原语支持\nABA问题(在进行CAS操作时候，另一个线程修改)")]),v._v(" "),e("li",[v._v("加version")]),v._v(" "),e("li",[v._v("A 1.0")]),v._v(" "),e("li",[v._v("B 2.0")]),v._v(" "),e("li",[v._v("A 3.0")]),v._v(" "),e("li",[v._v("cas(version)")]),v._v(" "),e("li",[v._v("如果基础类型 无所谓")]),v._v(" "),e("li",[v._v("如果引用类型")])]),v._v(" "),e("p",[v._v("Unsafe(jdk1.8) = c c++的指针")]),v._v(" "),e("ul",[e("li",[v._v("直接操作内存\n"),e("ul",[e("li",[v._v("allocateMemory putXX freeMemory pageSize")])])]),v._v(" "),e("li",[v._v("直接生成类实例\n"),e("ul",[e("li",[v._v("allocateInstance")])])]),v._v(" "),e("li",[v._v("直接操作类或者实例变量\n"),e("ul",[e("li",[v._v("objectFieldOffset getInt getObject")])])]),v._v(" "),e("li",[v._v("CAS相关操作\n"),e("ul",[e("li",[v._v("compareAndSwapObject Int Long")])])]),v._v(" "),e("li",[v._v("c -> malloc free")]),v._v(" "),e("li",[v._v("c++ -> new delete")])]),v._v(" "),e("h2",{attrs:{id:"juc包下atomicxxx类与新的同步机制：latch-semaphore等"}},[v._v("JUC包下AtomicXXX类与新的同步机制：Latch Semaphore等")]),v._v(" "),e("p",[v._v("ReentrantLock vs synchronized")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("cas vs sync")])]),v._v(" "),e("li",[e("p",[v._v("tryLock")])]),v._v(" "),e("li",[e("p",[v._v("lockInterruptibly")])]),v._v(" "),e("li",[e("p",[v._v("公平和非公平")])]),v._v(" "),e("li",[e("p",[v._v("CountDownLatch")])]),v._v(" "),e("li",[e("p",[v._v("CyclicBarrier")])]),v._v(" "),e("li",[e("p",[v._v("Phaser")])]),v._v(" "),e("li",[e("p",[v._v("ReadWriteLock")]),v._v(" "),e("ul",[e("li",[v._v("共享锁")]),v._v(" "),e("li",[v._v("排他锁")])])]),v._v(" "),e("li",[e("p",[v._v("Semaphore")]),v._v(" "),e("ul",[e("li",[v._v("限流")]),v._v(" "),e("li",[v._v("车道 收费站")])])])]),v._v(" "),e("h2",{attrs:{id:"locksupport，高频面试题，aqs源码，以及源码阅读方法论"}},[v._v("LockSupport，高频面试题，AQS源码，以及源码阅读方法论")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("TestLockSupport")])]),v._v(" "),e("li",[e("p",[v._v("淘宝面试题")]),v._v(" "),e("ul",[e("li",[v._v("实现一个容器，提供两个方法，add, size")]),v._v(" "),e("li",[v._v("写2个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2会给出提示并结束")]),v._v(" "),e("li",[v._v("面试题：写一个固定容量的同步器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用")])])]),v._v(" "),e("li",[e("p",[v._v("源码阅读技巧")])]),v._v(" "),e("li",[e("p",[v._v("AQS源码解析")])])]),v._v(" "),e("h2",{attrs:{id:"强软弱虚四种引用以及threadlocal的原理与源码"}},[v._v("强软弱虚四种引用以及ThreadLocal的原理与源码")]),v._v(" "),e("ul",[e("li",[v._v("AQS源码\n"),e("ul",[e("li",[v._v("VarHandle 1、普通属性也能进行原子操作 2、比反射快，直接操纵二进制码")])])]),v._v(" "),e("li",[v._v("强软弱虚\n"),e("ul",[e("li",[v._v("强 - 普通引用 Object obj = new Object()")]),v._v(" "),e("li",[v._v("软 - 内存不够才回收")]),v._v(" "),e("li",[v._v("弱 - 遇到gc就回收 应用 ThreadLocal")]),v._v(" "),e("li",[v._v("虚 -")])])]),v._v(" "),e("li",[v._v("ThreadLocal")])]),v._v(" "),e("p",[v._v("Memory Leak - 内存泄漏\nOOM((Out Of Memory)-内存溢出")])])}),[],!1,null,null,null);_.default=t.exports}}]);