(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{595:function(_,n,t){"use strict";t.r(n);var v=t(12),l=Object(v.a)({},(function(){var _=this,n=_.$createElement,t=_._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"网络编程之多路复用器及epoll精讲"}},[_._v("网络编程之多路复用器及Epoll精讲")]),_._v(" "),t("h3",{attrs:{id:"多路复用器"}},[_._v("多路复用器")]),_._v(" "),t("p",[_._v("多条路(IO)通过一个系统调用，获得其中有状态的IO，又程序自己对有状态的IO进行R/W")]),_._v(" "),t("p",[_._v("IO模型是同步的")]),_._v(" "),t("p",[_._v("只关注IO：不关注从IO读写完之后的事情\n同步：app自己R/W\n异步：kernel完成R/W 没有访问IO Buffer win:iocp")]),_._v(" "),t("p",[_._v("阻塞：BLOCKING\n非阻塞：NONBLOCKING")]),_._v(" "),t("p",[_._v("linux以及成熟的框架 netty\n同步阻塞\n同步非阻塞")]),_._v(" "),t("p",[_._v("SELECT POSIX\nPOLL\nEPOLL")]),_._v(" "),t("p",[_._v("linux epoll\nunix kqueue")]),_._v(" "),t("h4",{attrs:{id:"select"}},[_._v("SELECT")]),_._v(" "),t("p",[_._v("synchronous I/O multiplexing\nFD_SETSIZE(1024)")]),_._v(" "),t("h4",{attrs:{id:"poll"}},[_._v("POLL")]),_._v(" "),t("p",[_._v("没有FD_SETSIZE限制")]),_._v(" "),t("p",[_._v("多路复用器：select poll的弊端，问题：\n每次都要重新，重复传递fds\n每次内核被调用后，针对这次调用，触发一个遍历fds全量的复杂度")]),_._v(" "),t("p",[_._v("时钟中断 晶振")]),_._v(" "),t("p",[_._v("EPOLL之前callback 只是完成了将网卡发来的数据，走内核的网络协议栈(2、3、4)最终关联到fd的buffer，\n所以你某一时间从APP询问内核某一个或多个fd是否可R/W，会有状态返回")]),_._v(" "),t("p",[_._v("yum install man man-pages")]),_._v(" "),t("p",[_._v("cat /proc/sys/fs/epoll/max_user_watches")])])}),[],!1,null,null,null);n.default=l.exports}}]);