(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{588:function(e,l,v){"use strict";v.r(l);var _=v(12),i=Object(_.a)({},(function(){var e=this,l=e.$createElement,v=e._self._c||l;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"juc"}},[e._v("JUC")]),e._v(" "),v("h2",{attrs:{id:"线程池可用的各种高并发容器详解：copyonwritelist，blockingqueue等"}},[e._v("线程池可用的各种高并发容器详解：CopyOnWriteList，BlockingQueue等")]),e._v(" "),v("ul",[v("li",[e._v("容器 - Vector - Hashtable")]),e._v(" "),v("li",[e._v("CopyOnWriteList")]),e._v(" "),v("li",[e._v("ConcurrentHashMap")]),e._v(" "),v("li",[e._v("ConcurrentSkipListMap")]),e._v(" "),v("li",[e._v("BlockingQueue")]),e._v(" "),v("li",[e._v("目标 为ThreadPool做准备")])]),e._v(" "),v("p",[e._v("Vector和Hashtable自带锁，基本不用")]),e._v(" "),v("p",[e._v("Hashtable 方法上加锁 -> @since 1.0\nHashMap 无锁 -> @since 1.2\nCollections.synchronizedMap (SynchronizedMap) 锁力度变小 -> @since 1.2\nConcurrentHashMap -> @since 1.5")]),e._v(" "),v("ul",[v("li",[e._v("Vector -> Queue")]),e._v(" "),v("li",[e._v("Queue List区别")]),e._v(" "),v("li",[e._v("Queue添加了对多线程友好的API   offer peek poll")]),e._v(" "),v("li",[e._v("BlockingQueue put take 阻塞")])]),e._v(" "),v("h2",{attrs:{id:"详解线程池：自定义线程池，jdk自带线程池，forkjoin，源码解析等-一）"}},[e._v("详解线程池：自定义线程池，JDK自带线程池，ForkJoin，源码解析等(一）")]),e._v(" "),v("p",[e._v("Callable -> Runnable + Result\nFuture -> 存储执行的 将来才会产生结果\nFutureTask -> Future + Runnable\nCompletableFuture -> 管理多个Future")]),e._v(" "),v("ul",[v("li",[e._v("ThreadPoolExecutor")]),e._v(" "),v("li",[e._v("ForkJoinPool\n"),v("ul",[v("li",[e._v("分解汇总的任务")]),e._v(" "),v("li",[e._v("用很少的线程可以执行很多的任务（子任务）TPE做不到先执行子任务")]),e._v(" "),v("li",[e._v("CPU密集型")])])])]),e._v(" "),v("h2",{attrs:{id:"详解线程池：自定义线程池，jdk自带线程池，forkjoin，源码解析等-二）"}},[e._v("详解线程池：自定义线程池，JDK自带线程池，ForkJoin，源码解析等(二）")]),e._v(" "),v("p",[e._v("Executors -> 线程池工厂")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("newSingleThreadExecutor 为什么有单线程的线程池")]),e._v(" "),v("ul",[v("li",[e._v("有任务队列")]),e._v(" "),v("li",[e._v("生命周期管理")])])]),e._v(" "),v("li",[v("p",[e._v("newCachedThreadPool")])]),e._v(" "),v("li",[v("p",[e._v("newFixedThreadPool")])]),e._v(" "),v("li",[v("p",[e._v("什么时候用Cached 什么时候用Fixed")]),e._v(" "),v("ul",[v("li",[e._v("任务数目不稳定 忽高忽低 Cached")]),e._v(" "),v("li",[e._v("任务平稳")])])]),e._v(" "),v("li",[v("p",[e._v("newScheduledThreadPool")])]),e._v(" "),v("li",[v("p",[e._v("并发concurrent、并行parallel")]),e._v(" "),v("ul",[v("li",[e._v("并发：任务提交")]),e._v(" "),v("li",[e._v("并行：任务执行")])])]),e._v(" "),v("li",[v("p",[e._v("并行是并发的子集")])])]),e._v(" "),v("p",[e._v("Worker类")]),e._v(" "),v("ul",[v("li",[e._v("Runnable AQS")]),e._v(" "),v("li",[e._v("thread")])]),e._v(" "),v("h2",{attrs:{id:"单机压测工具jmh，单机最快mq-disruptor原理解析"}},[e._v("单机压测工具JMH，单机最快MQ - Disruptor原理解析")]),e._v(" "),v("ul",[v("li",[e._v("JMH\n"),v("ul",[v("li",[e._v("JMH 是 Java Microbenchmark Harness 的缩写")])])]),e._v(" "),v("li",[e._v("2013年首发\n"),v("ul",[v("li",[e._v("又JIT的开发人员开发")]),e._v(" "),v("li",[e._v("归于OpenJDK")])])])])])}),[],!1,null,null,null);l.default=i.exports}}]);